<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ScreenLink</title>
  <!-- TailwindCSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- html-to-image CDN -->
  <script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.min.js"></script>
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
  />
  <style>
    body {
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
  </style>
</head>
<body class="h-full bg-gradient-to-br from-slate-950 via-slate-950 to-slate-900 text-slate-100">
  <div class="flex flex-col h-full">
    <!-- Toolbar -->
    <header class="sticky top-0 z-10 backdrop-blur-xl bg-slate-900/80 border-b border-slate-800 shadow-xl">
      <div class="max-w-6xl mx-auto px-4 py-4 flex flex-wrap items-center gap-3">
        <div class="flex items-center gap-2 text-slate-100">
          <div class="text-lg font-semibold">ScreenLink</div>
          <span class="text-sm text-slate-400">Stitch your screenshots</span>
        </div>
        <div class="flex-1"></div>
        <div class="flex flex-wrap items-center gap-2">
          <input id="fileInput" type="file" accept="image/*" multiple class="hidden" />
          <button id="uploadBtn" class="px-3 py-2 rounded-lg bg-indigo-500 text-white shadow hover:bg-indigo-400 transition text-sm">Upload</button>
          <button id="copyBtn" class="px-3 py-2 rounded-lg bg-emerald-500 text-white shadow hover:bg-emerald-400 transition text-sm">Copy PNG to Clipboard</button>
          <button id="exportBtn" class="px-3 py-2 rounded-lg bg-blue-500 text-white shadow hover:bg-blue-400 transition text-sm">Export PNG</button>
          <label class="flex items-center gap-2 px-3 py-2 rounded-lg bg-slate-800 border border-slate-700 shadow text-sm text-slate-100">
            <span class="text-slate-200">Flow</span>
            <select id="orientationSelect" class="bg-transparent focus:outline-none">
              <option value="row">Left → Right</option>
              <option value="col">Top → Bottom</option>
            </select>
          </label>
          <label class="flex items-center gap-2 px-3 py-2 rounded-lg bg-slate-800 border border-slate-700 shadow text-sm text-slate-100">
            <span class="text-slate-200">Padding</span>
            <input id="paddingRange" type="range" min="16" max="96" value="32" class="accent-indigo-400" />
          </label>
          <label class="flex items-center gap-2 px-3 py-2 rounded-lg bg-slate-800 border border-slate-700 shadow text-sm text-slate-100">
            <span class="text-slate-200">Canvas gradient</span>
            <select id="gradientSelect" class="bg-transparent focus:outline-none"></select>
          </label>
          <button id="linkModeBtn" class="px-3 py-2 rounded-lg bg-amber-500 text-white shadow hover:bg-amber-400 transition text-sm">Link images with arrows</button>
          <button id="clearBtn" class="px-3 py-2 rounded-lg bg-rose-500 text-white shadow hover:bg-rose-400 transition text-sm">Clear</button>
        </div>
      </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-1 overflow-auto py-8">
      <div class="max-w-6xl mx-auto px-4">
        <div
          id="flowContainer"
          class="relative flex flex-row items-start min-h-[60vh] rounded-3xl shadow-2xl overflow-auto border border-slate-800 bg-slate-950/60"
          style="padding: 32px; gap: 16px; background: linear-gradient(135deg, #0ea5e9, #8b5cf6);"
        >
          <svg id="linkLayer" class="absolute inset-0 w-full h-full pointer-events-none"></svg>
          <div
            id="watermark"
            class="absolute bottom-4 right-5 pointer-events-none select-none text-xl md:text-2xl font-semibold text-white/40 tracking-wide flex items-center gap-2"
          >
            <span class="px-2 py-1 rounded-full bg-slate-900/60 border border-white/10 text-white/70 text-sm">https://screenlink.io</span>
          </div>
        </div>
        <p id="emptyState" class="mt-4 text-center text-slate-300">Upload or paste screenshots to get started. Drag cards to reorder. Arrow mode auto-links cards in order.</p>
      </div>
    </main>

    <!-- Toast -->
    <div id="toast" class="fixed bottom-5 left-1/2 -translate-x-1/2 px-4 py-2 rounded-full bg-emerald-500 text-white shadow-lg opacity-0 pointer-events-none transition-opacity">Copied!</div>
  </div>

  <script>
    // Utility: create a card wrapper for a given image source
    function createCard(src) {
      const card = document.createElement('div');
      card.className =
        'screenshot-card relative rounded-2xl shadow-xl bg-slate-900/70 p-3 cursor-move border border-slate-800 backdrop-blur-sm transition hover:-translate-y-0.5 hover:shadow-2xl flex flex-col gap-2';
      card.draggable = true;
      card.dataset.cardId = crypto.randomUUID();

      const img = document.createElement('img');
      img.src = src;
      img.alt = 'Screenshot';
      img.className = 'max-w-full h-auto rounded-lg select-none shadow-lg border border-slate-800';
      img.draggable = false; // prevent dragging the image itself

      card.appendChild(img);
      addDragEvents(card);
      return card;
    }

    const flowContainer = document.getElementById('flowContainer');
    const emptyState = document.getElementById('emptyState');
    let currentGap = 16;
    const arrowGap = 32;

    function toggleEmptyState() {
      emptyState.classList.toggle('hidden', flowContainer.querySelectorAll('.screenshot-card').length > 0);
    }

    // Drag and drop ordering
    let dragSrc = null;

    function getDropTarget(clientX, clientY) {
      const isRow = flowContainer.classList.contains('flex-row');
      const cards = Array.from(flowContainer.querySelectorAll('.screenshot-card')).filter((c) => c !== dragSrc);

      let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
      cards.forEach((card) => {
        const rect = card.getBoundingClientRect();
        const offset = isRow ? clientX - (rect.left + rect.width / 2) : clientY - (rect.top + rect.height / 2);

        if (offset < 0 && offset > closest.offset) {
          closest = { offset, element: card };
        }
      });
      return closest.element;
    }

    function addDragEvents(card) {
      card.addEventListener('dragstart', (e) => {
        dragSrc = card;
        e.dataTransfer.effectAllowed = 'move';
        // tiny transparent drag image to hide the ghost size
        const ghost = document.createElement('div');
        ghost.style.width = '1px';
        ghost.style.height = '1px';
        ghost.style.opacity = '0';
        document.body.appendChild(ghost);
        e.dataTransfer.setDragImage(ghost, 0, 0);
        setTimeout(() => document.body.removeChild(ghost), 0);
      });

      card.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      });

      card.addEventListener('drop', (e) => {
        e.stopPropagation();
        const beforeElement = getDropTarget(e.clientX, e.clientY) || card;
        if (dragSrc && dragSrc !== beforeElement) {
          flowContainer.insertBefore(dragSrc, beforeElement);
        }
        dragSrc = null;
        updateArrows();
      });
    }

    flowContainer.addEventListener('dragover', (e) => {
      if (!dragSrc) return;
      e.preventDefault();
      const beforeElement = getDropTarget(e.clientX, e.clientY);
      if (beforeElement === null) {
        flowContainer.appendChild(dragSrc);
      } else if (beforeElement !== dragSrc) {
        flowContainer.insertBefore(dragSrc, beforeElement);
      }
    });

    flowContainer.addEventListener('drop', (e) => {
      if (!dragSrc) return;
      e.preventDefault();
      dragSrc = null;
      updateArrows();
    });

    // File upload handling
    const fileInput = document.getElementById('fileInput');
    const uploadBtn = document.getElementById('uploadBtn');
    uploadBtn.addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files || []);
      files.forEach((file) => {
        if (!file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          const card = createCard(event.target.result);
          flowContainer.appendChild(card);
          toggleEmptyState();
          updateArrows();
        };
        reader.readAsDataURL(file);
      });
      fileInput.value = '';
    });

    // Paste support
    document.addEventListener('paste', async (e) => {
      const items = e.clipboardData?.items;
      if (!items) return;
      for (const item of items) {
        if (item.type.startsWith('image/')) {
          const file = item.getAsFile();
          if (!file) continue;
          const reader = new FileReader();
          reader.onload = (event) => {
            const card = createCard(event.target.result);
            flowContainer.appendChild(card);
            toggleEmptyState();
            updateArrows();
          };
          reader.readAsDataURL(file);
        }
      }
    });

    // Orientation toggle
    const orientationSelect = document.getElementById('orientationSelect');
    orientationSelect.addEventListener('change', () => {
      const value = orientationSelect.value;
      if (value === 'row') {
        flowContainer.classList.remove('flex-col');
        flowContainer.classList.add('flex-row');
      } else {
        flowContainer.classList.remove('flex-row');
        flowContainer.classList.add('flex-col');
      }
      updateArrows();
    });

    // Export PNG
    const exportBtn = document.getElementById('exportBtn');
    exportBtn.addEventListener('click', async () => {
      if (flowContainer.children.length === 0) return;
      try {
        const dataUrl = await htmlToImage.toPng(flowContainer);
        const link = document.createElement('a');
        link.download = 'screenlink.png';
        link.href = dataUrl;
        link.click();
      } catch (err) {
        console.error('Export failed', err);
      }
    });

    // Copy PNG to Clipboard
    const toast = document.getElementById('toast');
    function showToast() {
      toast.classList.remove('opacity-0');
      setTimeout(() => toast.classList.add('opacity-0'), 1500);
    }

    const copyBtn = document.getElementById('copyBtn');
    copyBtn.addEventListener('click', async () => {
      if (!navigator.clipboard || !window.ClipboardItem) {
        alert('Clipboard API not supported in this browser.');
        return;
      }
      if (flowContainer.children.length === 0) return;
      try {
        const blob = await htmlToImage.toBlob(flowContainer);
        if (!blob) return;
        const item = new ClipboardItem({ [blob.type]: blob });
        await navigator.clipboard.write([item]);
        showToast();
      } catch (err) {
        console.error('Copy failed', err);
      }
    });

    // Background gradient + padding controls
    const paddingRange = document.getElementById('paddingRange');
    const gradientSelect = document.getElementById('gradientSelect');

    const gradients = [
      { name: 'Aurora', from: '#0ea5e9', to: '#6366f1' },
      { name: 'Sunset Pop', from: '#f97316', to: '#ec4899' },
      { name: 'Mint Frost', from: '#34d399', to: '#22d3ee' },
      { name: 'Cyber Grape', from: '#a855f7', to: '#3b82f6' },
      { name: 'Velvet', from: '#ef4444', to: '#8b5cf6' },
      { name: 'Rose Noir', from: '#0f172a', to: '#be123c' },
      { name: 'Neon Lime', from: '#16a34a', to: '#22c55e' },
      { name: 'Steel', from: '#334155', to: '#1e293b' },
      { name: 'Creamsicle', from: '#fb923c', to: '#f97316' },
      { name: 'Candy', from: '#a855f7', to: '#ec4899' },
      { name: 'Oceanic', from: '#0ea5e9', to: '#14b8a6' },
      { name: 'Royal', from: '#312e81', to: '#9333ea' },
      { name: 'Dusk', from: '#0f172a', to: '#312e81' },
      { name: 'Signal', from: '#2563eb', to: '#f59e0b' },
      { name: 'Ink', from: '#020617', to: '#0ea5e9' },
      { name: 'Plasma', from: '#22d3ee', to: '#f472b6' },
      { name: 'Lagoon', from: '#14b8a6', to: '#0ea5e9' },
      { name: 'Magma', from: '#ef4444', to: '#fb923c' },
      { name: 'Cobalt', from: '#1d4ed8', to: '#0ea5e9' },
      { name: 'Grape Soda', from: '#581c87', to: '#a855f7' },
    ];

    gradients.forEach((g, idx) => {
      const option = document.createElement('option');
      option.value = idx;
      option.textContent = g.name;
      gradientSelect.appendChild(option);
    });
    gradientSelect.value = '0';

    function applyBackgroundStyles() {
      const preset = gradients[gradientSelect.value] || gradients[0];
      flowContainer.style.background = `linear-gradient(135deg, ${preset.from}, ${preset.to})`;
      const pad = Math.max(Number(paddingRange.value), 48);
      flowContainer.style.padding = `${pad}px`;
      flowContainer.style.gap = `${linkMode ? arrowGap : currentGap}px`;
    }

    gradientSelect.addEventListener('change', applyBackgroundStyles);
    paddingRange.addEventListener('input', applyBackgroundStyles);

    // Arrow linking logic
    const linkModeBtn = document.getElementById('linkModeBtn');
    const linkLayer = document.getElementById('linkLayer');
    let linkMode = false;
    const connections = [];

    function rebuildConnectionsFromOrder() {
      connections.length = 0;
      const cards = Array.from(flowContainer.querySelectorAll('.screenshot-card'));
      for (let i = 0; i < cards.length - 1; i++) {
        connections.push({ from: cards[i].dataset.cardId, to: cards[i + 1].dataset.cardId });
      }
    }

    function toggleLinkMode() {
      linkMode = !linkMode;
      linkLayer.classList.toggle('opacity-80', linkMode);
      linkModeBtn.classList.toggle('bg-amber-600', linkMode);
      linkModeBtn.classList.toggle('bg-amber-500', !linkMode);
      linkModeBtn.textContent = linkMode ? 'Arrow linking on' : 'Link images with arrows';
      flowContainer.style.gap = `${linkMode ? arrowGap : currentGap}px`;
      if (linkMode) rebuildConnectionsFromOrder();
      updateArrows();
    }

    linkModeBtn.addEventListener('click', toggleLinkMode);

    function updateArrows() {
      linkLayer.innerHTML = '';
      if (!linkMode) return;

      rebuildConnectionsFromOrder();
      const bounds = flowContainer.getBoundingClientRect();

      connections.forEach((connection) => {
        const fromEl = flowContainer.querySelector(`[data-card-id="${connection.from}"]`);
        const toEl = flowContainer.querySelector(`[data-card-id="${connection.to}"]`);
        if (!fromEl || !toEl) return;

        const fromRect = fromEl.getBoundingClientRect();
        const toRect = toEl.getBoundingClientRect();

        const startX = fromRect.right - bounds.left;
        const startY = fromRect.top + fromRect.height / 2 - bounds.top;
        const endX = toRect.left - bounds.left;
        const endY = toRect.top + toRect.height / 2 - bounds.top;

        const midX = (startX + endX) / 2;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', '#f59e0b');
        path.setAttribute('stroke-width', '4');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');

        const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        const size = 10;
        const angle = Math.atan2(endY - startY, endX - startX);
        const arrowX1 = endX - size * Math.cos(angle - Math.PI / 6);
        const arrowY1 = endY - size * Math.sin(angle - Math.PI / 6);
        const arrowX2 = endX - size * Math.cos(angle + Math.PI / 6);
        const arrowY2 = endY - size * Math.sin(angle + Math.PI / 6);
        arrowHead.setAttribute('points', `${endX},${endY} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`);
        arrowHead.setAttribute('fill', '#f59e0b');

        linkLayer.appendChild(path);
        linkLayer.appendChild(arrowHead);
      });
    }

    window.addEventListener('resize', () => {
      updateArrows();
    });

    // Clear flow
    const clearBtn = document.getElementById('clearBtn');
    clearBtn.addEventListener('click', () => {
      flowContainer.innerHTML = '';
      linkLayer.innerHTML = '';
      toggleEmptyState();
    });

    // Initialize orientation class and empty state
    orientationSelect.dispatchEvent(new Event('change'));
    toggleEmptyState();
    applyBackgroundStyles();
    updateArrows();
  </script>
</body>
</html>
